<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="keywords" content="周硕的博客, 前端博客">
  <meta name="description" content="周硕的个人博客，此博客是我记录工作和学习的地方。">
  <title>JavaScript常见原生DOM操作API总结 | 周硕的博客</title>
  
  
  <link rel="shortcut icon" href="/blog/assets/favicon.ico" >
  
  <link rel="stylesheet" href="/blog/css/highlight_themes/tomorrow.css">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <!-- global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111550549-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111550549-1');
</script>


  
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background: #333 url(/assets/header-bg2.jpg) no-repeat center; background-size:cover;">
        <div class='av-pic' style="background-image: url(/assets/logo.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>周硕的博客</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/zhoushuozh/">
                    <img src="/assets/github.svg" />
                </a>
            
        
            
                <a href="https://weibo.com/zhoushuozh/">
                    <img src="/assets/weibo.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>JavaScript常见原生DOM操作API总结</h1>
    </header>

    <section>
      <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM全称是Document Object Model(文档对象模型)，是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。</p>
<p>DOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。</p>
<a id="more"></a>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>
<p>几种常见的节点：</p>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li>
<li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li>
<li><code>Attribute</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段</li>
</ul>
<p>Node 对象定义了几个常量，对应这些类型值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType === Node.DOCUMENT_NODE <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>Node有一个属性<code>nodeType</code>表示Node的类型，它是一个整数，其数值分别表示相应的Node类型，不同节点的<code>nodeType</code>属性值和对应的常量如下：</p>
<ul>
<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>
<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>
<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>
<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>
<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>
<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>
<li>注释节点（Comment）：8，对应常量`Node.COMMENT_NODE</li>
</ul>
<p>上面说完了DOM的基本概念，下面将分类学习一下常用的DOM操作API。</p>
<h2 id="节点查询API"><a href="#节点查询API" class="headerlink" title="节点查询API"></a>节点查询API</h2><h4 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById"></a>document.getElementById</h4><p>根据元素id查找元素，大小写敏感，返回值是Element类型，如果不存在该元素，则返回null，如果有多个结果，只返回第一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'para1'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName"></a>document.getElementsByTagName</h4><p>根据标签查找元素，<code>*</code>表示查询所有标签，返回一个<code>HTMLCollection</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName"></a>document.getElementsByName</h4><p>根据元素的name属性查找，返回一个<code>NodeList</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单为 &lt;form name="x"&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="keyword">var</span> forms = <span class="built_in">document</span>.getElementsByName(<span class="string">'x'</span>);</span><br><span class="line">forms[<span class="number">0</span>].tagName <span class="comment">// "FORM"</span></span><br></pre></td></tr></table></figure>
<h4 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName"></a>document.getElementsByClassName</h4><p>根据类名查找元素，多个类名用空格分隔，返回一个<code>HTMLCollection</code>，另外，不仅仅是document，其它元素也支持<code>getElementsByClassName</code>方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = element.getElementsByClassName(names);</span><br></pre></td></tr></table></figure>
<p>如果要获取2个以上classname，可传入多个classname，每个用空格相隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'foo bar'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="document-querySelector和document-querySelectorAll"><a href="#document-querySelector和document-querySelectorAll" class="headerlink" title="document.querySelector和document.querySelectorAll"></a>document.querySelector和document.querySelectorAll</h4><p>这两个api很相似，通过css选择器来查找元素，注意选择器要符合<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors" target="_blank" rel="noopener">CSS选择器</a>的规则。</p>
<p>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。</p>
<p>这个例子中，会返回当前文档中第一个类名为 “<code>myclass</code>“ 的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">".myclass"</span>);</span><br></pre></td></tr></table></figure>
<p>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符。</p>
<p>下面的例子返回一个文档中所有的class为”<code>note</code>“或者 “<code>alert</code>“的<code>div</code>元素.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="built_in">document</span>.querySelectorAll(<span class="string">"div.note, div.alert"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="节点创建API"><a href="#节点创建API" class="headerlink" title="节点创建API"></a>节点创建API</h2><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p>通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>createElement</code>要注意：通过<code>createElement</code>创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用<code>appendChild</code>或<code>insertBefore</code>等方法将其添加到HTML文档树中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure>
<h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>用来创建一个文本节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.createTextNode(<span class="string">"我是文本节点"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(node);</span><br></pre></td></tr></table></figure>
<p><code>createTextNode</code>接收一个参数，这个参数就是文本节点中的文本，和<code>createElement</code>一样，创建后的文本节点也只是独立的一个节点，同样需要<code>appendChild</code>将其添加到HTML文档树中。</p>
<h4 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode"></a>cloneNode</h4><p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否采用深度克隆，如果为<code>true</code>,则该节点的所有后代节点也都会被克隆，如果为<code>false</code>，则只克隆该节点本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"para1"</span>),</span><br><span class="line"><span class="keyword">var</span> p_prime = p.cloneNode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h4><p>createDocumentFragment用来创建一个新的空白的文档片段。</p>
<p><code>DocumentFragment</code>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docfrag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  li.textContent = e;</span><br><span class="line">  docfrag.appendChild(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element  = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span><br><span class="line">element.appendChild(docfrag);</span><br></pre></td></tr></table></figure>
<p>上面代码中，文档片断<code>docfrag</code>包含四个<code>&lt;li&gt;</code>节点，这些子节点被一次性插入了当前文档。</p>
<h2 id="节点修改API"><a href="#节点修改API" class="headerlink" title="节点修改API"></a>节点修改API</h2><h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><p>appendChild我们在前面已经用到多次，接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(p);</span><br></pre></td></tr></table></figure>
<p>如果参数节点是 DOM 已经存在的节点，<code>appendChild</code>方法会将其从原来的位置，移动到新位置。</p>
<p>如果<code>appendChild</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code><strong>节点</strong>。</p>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h3><p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNode = parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>
<p><code>insertBefore</code>接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(p, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>
<p>上面代码中，新建一个<code>&lt;p&gt;</code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p>
<p>关于第二个参数参照节点还有两个注意的地方：</p>
<ol>
<li>refNode是必传的，如果不传该参数会报错</li>
<li>如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</li>
</ol>
<h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h3><p>removeChild顾名思义，就是从当前节点移除该子节点。返回值是移除的子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deletedChild = parent.removeChild(node);</span><br></pre></td></tr></table></figure>
<p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>
<p>如果被删除的节点不是其子节点，<code>removeChild</code>方法将报错。</p>
<h3 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h3><p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replacedNode = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p>
<h2 id="节点关系API"><a href="#节点关系API" class="headerlink" title="节点关系API"></a>节点关系API</h2><h3 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h3><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p>
<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>
<p>文档的第一层只有一个节点，就是 HTML 网页的第一个标签<code>&lt;html&gt;</code>，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>
<p>除了根节点，其他节点都有三种层级关系。</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<p>DOM 提供操作接口，用来获取这三种关系的节点。</p>
<h4 id="父关系API"><a href="#父关系API" class="headerlink" title="父关系API"></a>父关系API</h4><ul>
<li><code>parentNode</code>：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。</li>
<li><code>parentElement</code>：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；</li>
</ul>
<h4 id="子关系API"><a href="#子关系API" class="headerlink" title="子关系API"></a>子关系API</h4><ul>
<li><code>children</code>：返回一个实时的<code>HTMLCollection</code>，子节点都是Element，IE9以下浏览器不支持；</li>
<li><code>childNodes</code>：返回一个实时的<code>NodeList</code>，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；</li>
<li><code>firstChild</code>：返回第一个子节点，不存在返回null，与之相对应的还有一个<code>firstElementChild</code>；</li>
<li><code>lastChild</code>：返回最后一个子节点，不存在返回null，与之相对应的还有一个<code>lastElementChild</code>；</li>
</ul>
<h4 id="兄弟关系型API"><a href="#兄弟关系型API" class="headerlink" title="兄弟关系型API"></a>兄弟关系型API</h4><ul>
<li><code>previousSibling</code>：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。</li>
<li><code>nextSibling</code>：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。</li>
<li><code>previousElementSibling</code>：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</li>
<li><code>nextElementSibling</code>：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</li>
</ul>
<h2 id="元素属性API"><a href="#元素属性API" class="headerlink" title="元素属性API"></a>元素属性API</h2><h4 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h4><p><code>Element.getAttribute</code>方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line"><span class="keyword">var</span> id = mydiv.getAttribute(<span class="string">'id'</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码读取<code>mydiv</code>的<code>id</code>的值。</p>
<h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h4><p><code>Element.setAttribute</code>方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line">b.setAttribute(<span class="string">'name'</span>, <span class="string">'myButton'</span>);</span><br><span class="line">b.setAttribute(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p>
<p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于<code>&lt;button&gt;</code>元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p>
<h4 id="removeAttribute"><a href="#removeAttribute" class="headerlink" title="removeAttribute"></a>removeAttribute</h4><p><code>Element.removeAttribute</code>方法移除指定属性。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).removeAttribute(<span class="string">'id'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="元素样式API"><a href="#元素样式API" class="headerlink" title="元素样式API"></a>元素样式API</h2><h4 id="直接修改元素的样式"><a href="#直接修改元素的样式" class="headerlink" title="直接修改元素的样式"></a>直接修改元素的样式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elem.style.color = <span class="string">'red'</span>;</span><br><span class="line">elem.style.setProperty(<span class="string">'font-size'</span>, <span class="string">'16px'</span>);</span><br><span class="line">elem.style.removeProperty(<span class="string">'color'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle"></a>window.getComputedStyle</h4><p><code>window.getComputedStyle</code>方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="built_in">window</span>.getComputedStyle(div);</span><br><span class="line">styleObj.backgroundColor</span><br></pre></td></tr></table></figure>
<p>上面代码中，得到的背景色就是<code>div</code>元素真正的背景色。</p>
<h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p><code>getBoundingClientRect</code>用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clientRect = element.getBoundingClientRect();</span><br></pre></td></tr></table></figure>
<p>clientRect是一个<code>DOMRect</code>对象，包含width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，滚动页面时它们的值是会发生变化的。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul>
<li><a href="http://luopq.com/2015/11/30/javascript-dom/" target="_blank" rel="noopener">狼狼的蓝胖子</a></li>
<li><a href="http://javascript.ruanyifeng.com/dom/node.html" target="_blank" rel="noopener">DOM模型 - 阮一峰JavaScript</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model#HTML_%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">文档对象模型(DOM) - MDN</a></li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2018-04-05T13:38:39.000Z" itemprop="datePublished">
              2018-04-05
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/JavaScript/">JavaScript</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/DOM/">DOM</a> }
  </li>


            </div>
          
      </section>
    
     
</article>

  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk-container"></div>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'd50f82d1de5ab2dd34c6',
        clientSecret: '7ed79e0b3ad122582d5c8d7d5a295c1142743477',
        id: window.location.pathname,
        repo: 'comments',
        owner: 'zhoushuozh',
        admin: 'zhoushuozh'
    })
    gitalk.render('gitalk-container')
</script>

</div>

            <footer>
    <div>&copy; 2018 - 周硕 </div>
    <div>
    Powered by Hexo &nbsp; Theme icalm
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<!--<script>
var sp = new Pager('data-pager-shell')
</script>-->

<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>-->


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


</body>
</html>
