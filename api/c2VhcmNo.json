[{"title":"vue更新数据后视图没有刷新的问题","date":"2019-01-24T03:23:56.000Z","updated":"2019-02-15T03:54:46.762Z","content":"最近一直在用 Vue 做项目，遇到了个问题：在某些情况下，数据改变后视图并没有没有更新。这个问题其实我之前就遇到过一次，当时翻了文档解决了，也没有特意去深入研究一下这个问题，今天又遇到了这个问题，我就趁这次机会再总结一下。\n\n场景我写了个demo简单描述一下我遇到的问题：\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;demo&lt;/title&gt;    &lt;script src=\"https://cdn.bootcss.com/vue/2.5.22/vue.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;ul&gt;      &lt;li&gt;name: &#123;&#123;info.name&#125;&#125;&lt;/li&gt;      &lt;li&gt;ege: &lt;input type=\"text\" v-model=\"info.age\"&gt;&lt;/li&gt;      &lt;li&gt;&lt;button @click=\"onClear\"&gt;clear&lt;/button&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;br&gt;      &lt;/div&gt;  &lt;script&gt;    var app = new Vue(&#123;      el: \"#app\",      data: &#123;        info: &#123;          name: \"aaa\"        &#125;,        response: &#123;          age: 18        &#125;      &#125;,      created() &#123;        this.info = Object.assign(this.info, this.response)      &#125;,      methods: &#123;        onClear() &#123;          this.info.age = \"\";        &#125;      &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n这里的需求应该挺好理解：页面元素绑定了info对象，response对象是我请求到的数据，我将我请求到的数据用assingn方法合并到info对象中。\n这一步看起来是没有问题的，页面显示也是正常的。\n\n接下来我需要做一个清除操作，点击旁边的clear按钮触发onClear函数，清空input里的内容。但是，单击之后会发现，页面没有任何变化。\n把info打出来看一下：\n\ninfo.name确实已经被更改了，但是视图并没有刷新。很明显，vue并没有检测到数据的改动。\nVue如何追踪变化解决这个问题之前，我们先来简单了解一下vue是如何追踪数据变化的：\n\n把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。\n这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 \n\n在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。当对象下的访问器属性值发生了改变之后， 那么就会调用setter函数，这时vue就可以通过这个setter函数来追踪变化，调用相关函数来实现view视图的更新。\n对象更改检测现在回过头来看前面的问题，其实已经很明显了。因为 Vue 是通过递归遍历初始数据中的所有属性，并用 Object.defineProperty 把它们转化为 getter 和 setter 来实现数据观察的。如果一个属性在实例创建时不存在于初始数据中，那么 Vue 就没有办法观察这个属性了。 \n当我使用Object.assign方法合并对象的时候其实是把response里的属性添加到了info对象里，那这时候vue是没办法观察这个属性的。\n其实 Vue 文档里也提到了这个问题，怪我我看得时候不够认真(🤐)…\n\n受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。 由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。 \n\n解决这个问题，我们可以使用 Vue 的全局 Vue.set 方法：\n1Vue.set(app.info, 'age', '')\n还可以使用实例方法vm.$set，其实就是全局 Vue.set方法的别名。\n1this.$set(info, 'age', '')\t// 这里的this指向‘app’实例\n通过调用这些方法添加或者删除属性，就能够触发所对应的 DOM 更新。 \n如果是为已有对象对象赋予多个新属性（也就是我遇到的这种情况），比如使用 Object.assign() 或 _.extend()。在这种情况下，应该创建并合并到一个新对象里：\n123// this.info = Object.assign(this.info, this.request)// 替换为：this.info = Object.assign(&#123;&#125;, this.info, this.response)\n数组更改检测vue官网还提到了关于数组更改检测\n\n由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n\n当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n当你修改数组的长度时，例如：vm.items.length = newLength\n\n\n1234567var vm = new Vue(&#123;  data: &#123;    items: ['a', 'b', 'c']  &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的\n这两种情况也是数组都确实被更新了，只是vue并没有检测到数组的更新，所以并不会更到视图中。\n针对第一种情况，我们可以使用跟上面同样的方法解决，或者使用 splice：\n123456// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.setvm.$set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)\n第二个问题，也可以使用 splice:\n1vm.items.splice(newLength)","plink":"https://blog.zhoushuo.me/post/vue-model-view/"},{"title":"Vue组件间的通信","date":"2018-09-07T12:39:21.000Z","updated":"2019-02-15T03:50:56.163Z","content":"了解过Vue的人都知道，组件化在Vue中是一个相当重要的概念，组件化一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护，而组件间的通信也是我们经常遇到的操作。组件之间通信的方式可以分为三种，父组件与子组件通信，子组与父组件通信，兄弟组件间通信。\n\n父组件与子组件通信在Vue中，父子组件的关系可以总结为向下通过 prop 传递，向上通过事件传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。 \n一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。我们能够在组件实例中访问这个值，就像访问 data 中的值一样。 \n父组件：\nparent.vue12345678910111213&lt;template&gt;  &lt;child :mgs=\"message\"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;        message: 'hello world!',    &#125;  &#125;&#125;&lt;/script&gt;\n子组件：\nchild.vue123456789&lt;template&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: ['mgs']&#125;&lt;/script&gt;\n子组件与父组件通信父组件与子组件通信，我们可以调用vue内建的$emit并传入事件的名字，来向父级组件触发一个事件，然后在父组件上监听这个事件。\n子组件：\nchild2.vue1234567891011121314&lt;template&gt;  &lt;div @click=\"tellParent\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: ['mgs2'],  methods: &#123;    tellParent() &#123;      this.$emit('listenChild2', 'hello world!');    &#125;  &#125;&#125;&lt;/script&gt;\n父组件：\nparent2.vue123456789101112131415161718&lt;template&gt;  &lt;child :mgs2=\"message2\" @listenChild2=\"updateMgs2\"&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;        message2: 'hi!'    &#125;  &#125;,  methods: &#123;    updateMgs2(val)&#123;      this.message2 = val    &#125;  &#125;&#125;&lt;/script&gt;\n在父组件中绑定一个listenChild2的事件，然后给这个事件添加updateMgs2方法，当子组件child2通过点击事件tellParent触发listenChild2的时候，父组件里面的updateMgs2方法就会执行，并且数据通过参数的形式传递给父组件，从而实现通信的功能。 \n此外，在父组件中也可以使用 $children 可以访问子组件，子组件也可以通过 $parent 访问父组件中的数据。 \n兄弟组件间通信首先我先举个例子吗，便于我们理解：如果你想把你支付宝里的钱转到微信你会怎么做？我想大部分人都知道：现将支付宝里的钱提现到银行卡，然后将银行卡里的钱充值到微信里面\n所以你可能也猜到了，对于同级间组件进行通信处理的方法是，新建一个Vue实例作为事件总线，然后通过这个Vue实例来监听和触发事件。具体实现如下：\n\n在需要进行通信的同级组件引入event.js 。\nevent.js123import Vue from 'vue';let _bus = new Vue();export default _bus;\n\n在兄弟组件A中使用$emit触发事件。\n组件A:\ncomponentA.vue123456789101112131415&lt;template&gt;  &lt;div @click=\"tellCompB\"&gt;点击向组件B通信&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import _bus from 'event.js'export default &#123;  props: ['mgs'],  methods: &#123;    tellCompB() &#123;      _bus.$emit('listenCompA', 'from component A');    &#125;,  &#125;&#125;&lt;/script&gt;\n\n在兄弟组件B中使用$on监听事件。\n组件B:\ncomponentB.vue1234567891011121314151617&lt;template&gt;   &lt;div class=\"component-B\"&gt;&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import _bus from 'event.js'export default &#123;  data() &#123;    return &#123;        message: 'hi!'    &#125;  &#125;,  methods: &#123;    _bus.$on('listenCompA', data =&gt; this.message = data)  &#125;&#125;&lt;/script&gt;\n\n\n当组件AcomponentA触发listenCompA时，组件BcomponentB中的监听事件listenCompA就会被触发，数据通过参数的形式传入，从而实现同级组件间通信。 \n其他父组件通过$refs操作子组件在Vue中，在父组件里可以通过ref属性拿到子组件，从而可以调用子组件的方法。\n父组件：\n1&lt;child ref=\"child1\"&gt;&lt;/child&gt;\n然后父组件就可以通过$refs访问子组件的属性和方法了。\n1this.$refs.child1.child1Function\n注意：ref属性的命名不能用驼峰。\nVuex对于一些简单的组件间的通信其实这些方式足够用了，如果一个页面涉及到很多的组件，那么这种方法就不是那么简洁了，这是就需要用到Vue中很重要的一个插件了Vuex。\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n\n大家如果有兴趣的话可以去了解一下：What is Vuex?\n","plink":"https://blog.zhoushuo.me/post/vue-component-communication/"},{"title":"关于cookie、session和HTTP缓存","date":"2018-06-22T14:18:26.000Z","updated":"2019-02-15T06:11:45.613Z","content":"CookieCookie是什么\nHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。\n\n\nCookie的作用cookie比较常见的作用是用于识别用户身份。\n举个例子：当用户A去访问a.com的时候，服务器会给A一个独一无二的id=001(这就是cookie)，当用户A访问a.com的其他网页的时候，都会带着那个独一无二的id。当B用户来访问a.com的时候，服务器发现他没有任何标识，也会给他一个独一无二的id=002，所以借助cookie服务器端就能够分清楚谁是谁了。\nCookie的特点\n服务器通过 Set-Cookie 头给客户端一串字符串\n客户端每次访问相同域名的网页时，必须带上这段字符串\n客户端要在一段时间内保存这个Cookie\nCookie 默认在用户关闭页面后就失效，后台代码可以任意设置 Cookie 的过期时间。比如max-age和后面要讲的Expires\n大小大概在 4kb 以内\n\nCookie存在的问题\n用户可以随意篡改 Cookie 。\n\nCookie 的存储大小有限制： 4KB 左右。\n\n\nSessionSession是什么维基百科的解释：\n\n在计算机科学领域来说，尤其是在网络领域，会话（session）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分。 \n\n简单来说，session 是一种在服务器端保存数据的机制。服务器通过读取浏览器发送的 cookie 和 服务器端的 session 来交换数据。 session 的作用和 cookie 的作用大致相同。最大的不同点在于两者的安全性和实现方式。\nSession的实现\n产生 sessionID：session 是基于 cookie 的一种方案，所以，首先要产生 cookie。client 第一次访问 server，server 生成一个随机数，命名为 sessionID，并将其放在响应头里，以 cookie 的形式返回给 client，client 以处理其他 cookie 的方式处理这段 cookie。大概是这样：cookie：sessionID=135165432165\n保存 sessionID： server 将要保存的数据保存在相对应的 sessionID 之下，再将 sessionID 保存到服务器端的特定的保存 session 的内存中（如 一个叫 session 的哈希表）\n使用 session： client 再次访问 server，会带上首次访问时获得的 值为 sessionID 的cookie，server 读取 cookie 中的 sessionID，根据 sessionID 到保存 session 的内存寻找与 sessionID 匹配的数据，若寻找成功就将数据返回给 client。\n\nession 和 Cookie 的区别\nsession 在服务器端，cookie 在客户端。\nsession 用户无法查看和修改，cookie 用户可以查看修改。\nsession 的实现依赖于 sessionID，而 sessionID 又存储在 cookie 上，所以也可以说：session 是基于 cookie 实现的一种数据存储方式。 \n\nLocalStorageLocalStorage是什么localStorage 是 HTML5 提供的一个 API。\n localStorage 的实质是一个hash（哈希表），是一个存在于浏览器上的 hash（哈希表）。\n localStorage 提供了几个 API 来添加、读取、删除 localStorage：\n\nlocalStorage.setItem(key, value) ：往 hash 中添加 key: value 的数据 \nlocalStorage.getItem(key)：读取 hash 中 key 的值 \nlocalStorage.removeItem(key)：删除 hash 中的 key \nlocalStorage.clear()：清空整个localStorage\n\nLocalStorage 和 Cookie 的区别每个域名 cookie 的大小是4Kb，每个域名 localStorage 的最大存储量的一般为 5MB左右，Chrome 10MB 左右。\n cookie 的使用要通过 HTTP，客户端每次访问相同域名时会带上 cookie，而 localStorage 与 HTTP 没有一毛钱关系。 \nlocalStorage 理论上永久有效，除非用户清理缓存；cookie默认有效时间是二十分钟左右，用户关闭页面后就失效，后台可以设置 cookie 的过期时间。 \nsessionStoragesessionStorage 的所有性质基本上与 localStorage 一致，唯一的不同区别在于：\nsessionStorage 在用户关闭页面（会话结束）后就失效，而localStorage一直有效。 \nCache-ControlCache-Control是什么Cache-Control 通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。缓存指令是单向的, 这意味着在请求设置的指令，在响应中不一定包含相同的指令。 \nCache-Control 有 2 种使用方式：\n\n以请求头形式使用 客户端可以在 HTTP 请求中使用 Cache-Control 指令\n\n1request.setHeader('Cache-Control','max-age=99999999') // 将此次请求的资源缓存 99999999 秒\n\n以响应头形式使用 服务器(node版本)可以在响应请求时，设置 Cache-Control\n\n1response.setHeader('Cache-Control','max-age=99999999')  // 将此次请求的资源缓存 99999999 秒\nCache-Control 的作用Cache-Control 使用缓存机制，用来缩短二次访问的响应时间，提高页面响应性能，实现web性能优化。 \nExpiresExpires 是以前版本的缓存控制，如果你设置了 Cache-Control，那么 Expires 会失效。 \n需要注意的是。Expires 使用的是本地时间，会受本地事件影响。  \nCache-Control 和 Expires ，优先使用 Cache-Control。\nEtag\nETag HTTP响应头是资源的特定版本的标识符。 Etag 是 HTTP 的内容，通过匹配标识符来判断资源是否需要下载。\n\nCache-Control: max-age 缓存 与 ETag 的区别\nCache-Control 通过 max-age 设置缓存的有效时间（持续时间），表示在 n 秒内不要再去向服务器要这个资源了，直接从内存缓存里面获得。\nETag是通过匹配标识符（一串md5值）来判断资源是否需要下载，如果匹配，服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用。\nCache-Control 不访问服务器，有时间限制；ETag 访问服务器，无时间限制。\n\nlast-Modified\nThe Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 \n\nlast-Modified 的作用及使用方法和 Etag 基本一致。\n其他Cookie 如何设置过期时间？Expires 指定了一个日期/时间， 在这个日期/时间之后 cookie 过期； Cache-Control:max-age指定了一个秒数，经过此秒数后 cookie 过期。\n如何删除cookie服务器端可以通过设置 Expires、Cache-Control: max-age将 Cookie 设置为过期状态 客户端可以通过document.cookie API 删除 cookie 。\n","plink":"https://blog.zhoushuo.me/post/cookie-session-http-cache/"},{"title":"理解JS中的闭包","date":"2018-05-19T06:51:03.000Z","updated":"2019-02-15T03:53:03.588Z","content":"什么是闭包简单来说，闭包就是能够读取其他函数内部变量的函数。\n\n如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。\n由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n123456789function f1()&#123;    var n=123;    function f2()&#123;        console.log(n);     &#125;    return f2;&#125;var result = f1();result();   // 123\n上面代码中函数 f2 就是闭包，即能够读取其他函数内部变量的函数。\n闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n1234567891011function increased(start) &#123;  return function () &#123;    return start++;  &#125;;&#125;var inc = increased(5);inc() // 5inc() // 6inc() // 7\n上面代码中，start 是函数 incrementor 的内部变量。通过闭包，start 的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。\n闭包的另一个用处，是封装对象的私有属性和私有方法。\n","plink":"https://blog.zhoushuo.me/post/js-closure/"},{"title":"JS中的call、apply、bind","date":"2018-05-10T14:18:26.000Z","updated":"2019-02-15T03:57:50.802Z","content":"在JavaScript中，call、apply和bind 是Function对象自带的三个方法，这三个方法的共同点：\n\n都是用来改变函数的this对象的指向的。\n第一个参数都是this要指向的对象。\n都可以利用后续参数传参。\n\n\n定义call语法 ：\n1fun.call(thisArg, arg1, arg2, ...)\n\ncall() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表) 。\n\n可以让call()中的对象调用当前对象所拥有的function。可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。 \napply语法：1fun.apply(thisArg, [argsArray])\n\napply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 \n\n在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 \nbind\nbind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 \n\n语法：1fun.bind(thisArg[, arg1[, arg2[, ...]]])\nbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call。当新函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 \n区别call和apply的区别他们俩之间的差别在于参数的区别，call和aplly的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。 \n123456function hello(name,age)&#123;    console.log(name);    console.log(age);&#125;hello.call(this,\"tsrot\",24);hello.apply(this,[\"tsrot\",24]);\ncall, apply与bind的差别call 和 apply 改变了函数的 this 上下文后便执行该函数, 而 bind 则是返回改变了上下文的一个函数  \n1234567891011var obj = &#123;    x: 81,&#125;;var foo = &#123;    getX: function() &#123;        return this.x;    &#125;&#125;console.log(foo.getX.bind(obj)());  console.log(foo.getX.call(obj));    console.log(foo.getX.apply(obj));\n运用场景实现继承1234567891011function Animal(name) &#123;    this.name = name;    this.showName = function () &#123;      console.log(this.name);    &#125;&#125;function Cat(name) &#123;    Animal.call(this, name); &#125;var cat = new Cat('Black Cat');cat.showName();\n数组追加12345678910var arr1 = [1,2,3]var arr2 = [4,5,6][].push.apply(arr1, arr2)// 使用一个辅助的空数组（为了访问非静态方法)，就是把arr2利用apply的数组参数特性push到arr1中.// 这样通过解构可以写成 arr1.push(...arr2), 如果需要返回一个全新的对象，还可以使用 [...arr1, ...arr2]。// 还可以写成var newArr =  arr1.concat(arr2)// arr1 [1, 2, 3, 4, 5, 6]// arr2 [4,5,6]\n将伪数组转化为数组js中的伪数组具有length属性，并且可以通过0、1、2…下标来访问其中的元素，但是没有Array中的push、pop等方法。我们可以利用call、apply来将其转化为真正的数组这样便可以方便地使用数组方法了。 \n12345678910var arrayLike = &#123;    0: 'shifeng',    1: 'xingyun',    2: 'ruxue',    length: 3&#125;var arr = Array.prototype.slice.call(arrayLike)// 上面arr便是一个包含arrayLike元素的真正的数组啦.// 注意数据结构必须是以数字为下标而且一定要有length属性!\n","plink":"https://blog.zhoushuo.me/post/call-apply-bind/"},{"title":"移动端Web页面适配方案","date":"2018-04-25T16:00:00.000Z","updated":"2019-02-15T03:24:20.936Z","content":"移动端越来越被大众所接收，各个移动端设备，分辨率大小不一致，为了适应各种移动端设备，完美呈现应有的布局效果，目前也有好几种移动端适配的技术方案，今天我总结一下其中我常用的两种。\n\n适配方式移动端适配主要有两大不同的方向：\n\n响应式布局：它是根据屏幕大小自动的调整布局位置（非单纯的缩放），实现适配。\n自适应布局：它是根据屏幕大小自动的缩放大小，实现适配。\n\n媒体查询（Meida Queries）在CSS中使用 Meida Queries：\n123@media screen and (max-width: 600px) &#123; true/*当屏幕尺寸小于600px时的CSS样式*/&#125;\n在引用css的时候加上media属性：\n1&lt;link rel=\"stylesheet\" href=\"mobile.css\" media=\"(max-width:768px)\"&gt; &lt;!--当页面框小于768px时引用--&gt;\nmedia query的好处在于可以做到设备像素比的判断，方法简单，成本低，特别是对移动和PC维护同一套代码的时候。\n但缺点也很明显：代码量比较大，基本就是体力活，维护不方便。为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片资源。为了兼顾移动端和PC端各自响应式的展示效果，难免会损失各自特有的交互方式。\n动态REM什么是 remrem 单位代表根元素的 font-size 大小，例如 &lt;html&gt;元素的 font-size是16px，那么 1rem 就等于 16px。\nrem 适配先看下面这个例子：\n1234567html &#123;    font-size:20px;&#125;div &#123;    width: 10rem; /* width=200px */    height：10rem; /* height=200px */&#125;\n先给html设置font-size为20px，那么1rem就是20px，然后给div设置宽高为10rem，这时div的宽高就是20px*10=200px。\n根据根元素的font-size值来改变自身的值，由此我们应该可以联想到我们可以给html设定不同的值，从而达到我们css样式中的适配效果。\nrem 值计算由于我们所写出的页面是要在不同的屏幕大小设备上运行的，所以我们在写样式的时候必须要先以一个确定的屏幕来作为参考，这个就由我们拿到的视觉稿来定：假如现在我们拿到的设计稿宽度是 640px：\n1rem = window.innerWidth  / 10\n这样计算出来的rem基准值就是64，这里为什么要除以10呢，是因为不想让html的font-size太大，那么不除以100呢，因为640除以100就小于12了，有些浏览器最小字体是不能小于12px的。这样1rem就等于64px，如果要设置一个宽度320px的div，单位换成rem的话就是320/64 = 5rem了。\n如果利用 rem 来设置 css 的值，一般要通过一层计算才行，这在我们写 css 中，其实算比较繁琐的一步操作了。\n完全可以利用scss来解决这个问题，例如我们可以写一个 scss 的 function px2rem即：\n1234@function px2rem($px)&#123;    $rem : 64px; /* 设计稿宽度是640px */    @return ($px/$rem) + rem;&#125;\n这样，当我们写具体数值的时候就可以写成：\n1width: px2rem(320px);\n生成的css文件就是：\n1width: 5rem; /* 320/64=5rem */\n动态调整 rem接下来我就可以通过不同的屏幕去动态设置html的font-size：\n1document.getElementsByTagName('html')[0].style.fontSize = window.innerWidth / 10 + 'px';\n这样一来，对于设计稿上任何一个尺寸换成rem后，在任何屏幕分辨率下对应的尺寸占屏幕宽度的百分比相同。所以这种布局可以百分比还原设计图。如过想随着窗口大小变化自动调整，还可以绑定页面的resize事件来达到变化时更新 html 的 font-size 。\n","plink":"https://blog.zhoushuo.me/post/mobile-web-adaptation/"},{"title":"从输入URL到页面加载完成的过程中都发生了什么","date":"2018-04-24T16:00:00.000Z","updated":"2019-02-15T03:12:40.682Z","content":"这是一道经典的面试题，面试官会根据你回答的内容追问下探，既考广度又考深度。关于此问题的文章网上也是一抓一大把，我写这篇博客的目的主要是从前端的角度屡一下这个过程，加深一下理解。\n\n大概流程是这样的：\n\nDNS解析\nTCP连接\n发送HTTP请求\n服务器处理请求并返回HTTP报文\n浏览器解析渲染页面\n连接结束\n\n1. 查找 IP 地址每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。\n浏览器会根据浏览器缓存-&gt;系统缓存(host)-&gt;路由器缓存-&gt;DNS服务器，逐级递归向上找,找到该域名对应的IP地址。\nDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；至此，浏览器已经得到了域名对应的 IP 地址。\n补充：\n\n域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，\nIP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限。\n\n2. 建立TCP连接得到服务器 IP 地址止后，浏览器在传输层发起一条到达服务器的 TCP 连接，建立 TCP 三次握手。\n第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)\n第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手。\n通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。\n为保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。\n3. HTTP发起请求HTTP 请求报文由四部分组成：请求行、请求头、空行、消息体。\n\n一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 方法，更加不常用的还有 HEAD 和 OPTION 以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。\n4. 服务器处理请求服务器在收到浏览器发送的 HTTP 请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码，响应头，响应报文三个部分。\nHTTP状态码共分为5种类型：\n1**  信息，服务器收到请求，需要请求者继续执行操作\n2**  成功，操作被成功接收并处理\n3**  重定向，需要进一步的操作以完成请求\n4**  客户端错误，请求包含语法错误或无法完成请求\n5**  服务器错误，服务器在处理请求的过程中发生了错误\n以下最常见的几种 HTTP 状态码：\n\n200 - 请求成功\n301 - 资源（网页等）被永久转移到其它URL\n404 - 请求的资源（网页等）不存在\n500 - 内部服务器错误\n\n5. 页面渲染当浏览器接收到报文，根据收到的资源的类型，进行语法解析，解析相应的内部数据结构，然后将资源组织成屏幕上显示的图像，这个过程叫渲染。网页渲染是浏览器最复杂、最核心的功能。\n\n浏览器会解析三个东西： \n\nHTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。 \n\nCSS，解析 CSS 会产生 CSS 规则树。 \n\nJavascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.\n\n\n解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree，可以理解为“画”元素。\n补充：\n构建 DOM Tree 的过程中，如果遇到了由 &lt;script&gt; 标签包起来的 js 动态脚本代码，那么会把代码送到 js 引擎里面去跑，如果遇到了 &lt;style&gt;标签包围起来的 css 代码，也会保存下来，用于稍后的渲染。如果遇到了 img 等引用外部文件的标签，那么浏览器会根据指定的 url 再次发起一个新的 HTTP 请求，去把这个文件拉取回来。\n6. 关闭TCP连接通过四次挥手关闭连接：\n第一次挥手：浏览器发完数据后，发送 FIN 请求断开连接。\n第二次挥手：服务器收到这个FIN，发回一个 ACK 表示同意。\n第三次挥手：服务器关闭浏览器的连接，发送一个 FIN 给浏览器。\n第四次挥手：浏览器发回 ACK 报文确认。\n补充：\n由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\n至此，整个流程基本就完成了，当然，以上只是一些很简单的介绍，还有很多复杂的细节没有提到，有时间我还会继续补充完善。\n参考内容\n从输入 URL 到页面加载完成的过程中都发生了什么\n简明理解三次握手和四次挥手\n从点击到呈现 — 详解一次HTTP请求\n浏览器加载、解析、渲染的过程\n\n","plink":"https://blog.zhoushuo.me/post/from-url-page/"},{"title":"JavaScript常见原生DOM操作API总结","date":"2018-04-05T13:38:39.000Z","updated":"2019-02-15T03:01:54.435Z","content":"随着Vue、React等MV*框架的出现，jQuery时代提供的强大便利的操作DOM的API在前端项目里用得越来越少，数据驱动视图的模式越来越深入人心，加上DOM操作的成本非常高，操作DOM越来越不被提倡。但在一些特殊情况下，操作DOM还是避免不了的，本文就简单总结一下DOM的基本概念和一些常用的DOM操作API。\n\n基本概念DOMDOM全称是Document Object Model(文档对象模型)，是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。\nDOM 只是一个接口规范，可以用各种语言实现，例如 Python。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最常见的任务，离开了 DOM，JavaScript 就无法控制网页。\n节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。\n几种常见的节点：\n\nDocument：整个文档树的顶层节点\nDocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;）\nElement：网页的各种HTML标签（比如&lt;body&gt;、&lt;a&gt;等）\nAttribute：网页元素的属性（比如class=&quot;right&quot;）\nText：标签之间或标签包含的文本\nComment：注释\nDocumentFragment：文档的片段\n\nNode 对象定义了几个常量，对应这些类型值。\n1document.nodeType === Node.DOCUMENT_NODE // true\nNode有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型，不同节点的nodeType属性值和对应的常量如下：\n\n文档节点（document）：9，对应常量Node.DOCUMENT_NODE\n元素节点（element）：1，对应常量Node.ELEMENT_NODE\n属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE\n文本节点（text）：3，对应常量Node.TEXT_NODE\n文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE\n文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE\n注释节点（Comment）：8，对应常量`Node.COMMENT_NODE\n\n上面说完了DOM的基本概念，下面将分类学习一下常用的DOM操作API。\n节点查询APIdocument.getElementById根据元素id查找元素，大小写敏感，返回值是Element类型，如果不存在该元素，则返回null，如果有多个结果，只返回第一个。\n1var elem = document.getElementById('para1');\ndocument.getElementsByTagName根据标签查找元素，*表示查询所有标签，返回一个HTMLCollection。\n1var paras = document.getElementsByTagName('p');\ndocument.getElementsByName根据元素的name属性查找，返回一个NodeList。\n123// 表单为 &lt;form name=\"x\"&gt;&lt;/form&gt;var forms = document.getElementsByName('x');forms[0].tagName // \"FORM\"\ndocument.getElementsByClassName根据类名查找元素，多个类名用空格分隔，返回一个HTMLCollection，另外，不仅仅是document，其它元素也支持getElementsByClassName方法.\n1var elements = element.getElementsByClassName(names);\n如果要获取2个以上classname，可传入多个classname，每个用空格相隔。\n1var elements = document.getElementsByClassName('foo bar');\ndocument.querySelector和document.querySelectorAll这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。\ndocument.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。\n这个例子中，会返回当前文档中第一个类名为 “myclass“ 的元素：\n1var el = document.querySelector(\".myclass\");\ndocument.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符。\n下面的例子返回一个文档中所有的class为”note“或者 “alert“的div元素.\n1var matches = document.querySelectorAll(\"div.note, div.alert\");\n节点创建APIcreateElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。\n1var div = document.createElement(\"div\");\n使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。\n12var div = document.createElement(\"div\");document.body.appendChild(div);\ncreateTextNode用来创建一个文本节点：\n12var node = document.createTextNode(\"我是文本节点\");document.body.appendChild(node);\ncreateTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中。\ncloneNodecloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否采用深度克隆，如果为true,则该节点的所有后代节点也都会被克隆，如果为false，则只克隆该节点本身。\n12var p = document.getElementById(\"para1\"),var p_prime = p.cloneNode(true);\ncreateDocumentFragmentcreateDocumentFragment用来创建一个新的空白的文档片段。\nDocumentFragment是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。\n12345678910var docfrag = document.createDocumentFragment();[1, 2, 3, 4].forEach(function (e) &#123;  var li = document.createElement('li');  li.textContent = e;  docfrag.appendChild(li);&#125;);var element  = document.getElementById('ul');element.appendChild(docfrag);\n上面代码中，文档片断docfrag包含四个&lt;li&gt;节点，这些子节点被一次性插入了当前文档。\n节点修改APIappendChildappendChild我们在前面已经用到多次，接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。\n12var p = document.createElement('p');document.body.appendChild(p);\n如果参数节点是 DOM 已经存在的节点，appendChild方法会将其从原来的位置，移动到新位置。\n如果appendChild方法的参数是DocumentFragment节点，那么插入的是DocumentFragment的所有子节点，而不是DocumentFragment节点本身。返回值是一个空的DocumentFragment节点。\ninsertBeforeinsertBefore方法用于将某个节点插入父节点内部的指定位置。\n1var insertedNode = parentNode.insertBefore(newNode, referenceNode);\ninsertBefore接受两个参数，第一个参数是所要插入的节点newNode，第二个参数是父节点parentNode内部的一个子节点referenceNode。newNode将插在referenceNode这个子节点的前面。返回值是插入的新节点newNode。\n12var p = document.createElement('p');document.body.insertBefore(p, document.body.firstChild);\n上面代码中，新建一个&lt;p&gt;节点，插在document.body.firstChild的前面，也就是成为document.body的第一个子节点。\n关于第二个参数参照节点还有两个注意的地方：\n\nrefNode是必传的，如果不传该参数会报错\n如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾\n\nremoveChildremoveChild顾名思义，就是从当前节点移除该子节点。返回值是移除的子节点。\n1var deletedChild = parent.removeChild(node);\n被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。\n如果被删除的节点不是其子节点，removeChild方法将报错。\nreplaceChildreplaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。\n1var replacedNode = parentNode.replaceChild(newChild, oldChild);\n上面代码中，replaceChild方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild。\n节点关系API节点树一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。\n浏览器原生提供document节点，代表整个文档。\n文档的第一层只有一个节点，就是 HTML 网页的第一个标签&lt;html&gt;，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。\n除了根节点，其他节点都有三种层级关系。\n\n父节点关系（parentNode）：直接的那个上级节点\n子节点关系（childNodes）：直接的下级节点\n同级节点关系（sibling）：拥有同一个父节点的节点\n\nDOM 提供操作接口，用来获取这三种关系的节点。\n父关系API\nparentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。\nparentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；\n\n子关系API\nchildren：返回一个实时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持；\nchildNodes：返回一个实时的NodeList，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；\nfirstChild：返回第一个子节点，不存在返回null，与之相对应的还有一个firstElementChild；\nlastChild：返回最后一个子节点，不存在返回null，与之相对应的还有一个lastElementChild；\n\n兄弟关系型API\npreviousSibling：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。\nnextSibling：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。\npreviousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。\nnextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。\n\n元素属性APIgetAttributeElement.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。\n12var mydiv = document.getElementById('mydiv');var id = mydiv.getAttribute('id');\n上面代码读取mydiv的id的值。\nsetAttributeElement.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。\n123var b = document.querySelector('button');b.setAttribute('name', 'myButton');b.setAttribute('disabled', true);\n上面代码中，button元素的name属性被设成myButton，disabled属性被设成true。\n这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值true就会变成字符串true；其次，上例的disable属性是一个布尔属性，对于&lt;button&gt;元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此setAttribute方法里面可以将disabled属性设成任意值。\nremoveAttributeElement.removeAttribute方法移除指定属性。该方法没有返回值。\n1document.getElementById('div1').removeAttribute('id')\n元素样式API直接修改元素的样式123elem.style.color = 'red';elem.style.setProperty('font-size', '16px');elem.style.removeProperty('color');\nwindow.getComputedStylewindow.getComputedStyle方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。\n123var div = document.querySelector('div');var styleObj = window.getComputedStyle(div);styleObj.backgroundColor\n上面代码中，得到的背景色就是div元素真正的背景色。\ngetBoundingClientRectgetBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：\n1var clientRect = element.getBoundingClientRect();\nclientRect是一个DOMRect对象，包含width、height、left、top、right、bottom，它是相对于窗口顶部而不是文档顶部，滚动页面时它们的值是会发生变化的。\n参考内容\nDOM模型 - 阮一峰JavaScript\n狼狼的蓝胖子\n文档对象模型(DOM) - MDN\n\n","plink":"https://blog.zhoushuo.me/post/dom-api/"},{"title":"为博客添加Gitalk评论插件","date":"2018-03-21T18:32:49.000Z","updated":"2019-02-15T03:59:17.619Z","content":"之前体验过畅言、来必力、gitalk等评论插件，体验最好的就是gitalk了。我目前用的icalm主题内置了 Disqus评论插件，用着还行，但在国内的加载速度那个惨啊… 所以决定还是换回gitalk。\n\n关于GitalkGitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 MarkDown语法\n主要特性：\n\n使用 Github 登录\n支持多语言 [en, zh-CN, zh-TW, es-ES, fr]\n支持个人或组织\n无干扰模式（设置 distractionFreeMode 为 true 开启）\n快捷键提交评论 （cmd|ctrl + enter）\n支持MarkDown语法\n\n安装Gitalk提供了两种方式：\n\n直接引入\n\n12&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt;\n\nnpm 安装\n\n1$ npm i --save gitalk\n12import 'gitalk/dist/gitalk.css'import Gitalk from 'gitalk'\n使用新建仓库Github上新建一个仓库，操作简单，这里就不废话了。\n创建OAuth ApplicationGitalk 需要一个 Github Application，点击这里申请。当然，也可以在用户头像下的setting下的Developer settings中new一个Application，然后填写相应的参数。\n\n完成后会生成相应的clientIDandclientSecret。\n集成 Gitalk找到icalm/layout/_partial/comment.ejs文件，把这段代码粘进去。注意，不同的主题方式不太一样。\n1234567891011121314&lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt;&lt;div id=\"gitalk-container\"&gt;&lt;/div&gt;&lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    var gitalk = new Gitalk(&#123;        clientID: '&lt;%= theme.gitalk.clientID %&gt;',        clientSecret: '&lt;%= theme.gitalk.clientSecret %&gt;',        id: window.location.pathname,        repo: '&lt;%= theme.gitalk.repo %&gt;',        owner: '&lt;%= theme.gitalk.owner %&gt;',        admin: '&lt;%= theme.gitalk.admin %&gt;'    &#125;)    gitalk.render('gitalk-container')&lt;/script&gt;\n修改主题配置文件icalm/_config.yml中增加以下内容。\n12345678#gitalk settingsgitalk:  enable: true #用来做启用判断可以不用  owner: #Github 用户名,  repo: #储存评论issue的github仓库名  admin: #Github 用户名,  clientID: #`Github Application clientID`  clientSecret: #`Github Application clientSecret`\n在../post.ejs文件末尾添加 ：（post.ejs是我的文章模板，大家根据自己的需求添加就行）\n123&#123;% elseif theme.gitalk.enable %&#125;true&lt;%- partial('_partial/comment') %&gt;&#123;% endif %&#125;\n小结到这里基本就大功告成了，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。\n当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 repo的仓库下创建对应 issue。\n","plink":"https://blog.zhoushuo.me/post/hexo-gitalk/"},{"title":"博客从Firekylin迁移到Hexo","date":"2018-03-20T16:00:00.000Z","updated":"2019-02-15T03:58:37.757Z","content":"之前使用的一直是Firekylin，Firekylin是由360公司Web前端工程师组成的专业团队 75Team 进行开发和维护，基于ThinkJS开发，快速很快且后台管理很方便。但是前些天突然想把博客放到二级目录，在折腾的过程中出现了一些问题，如静态资源无法加载，尝试了很多办法，最终都没不能完全解决这个问题。查了一下，Firekylin在设计之初没有考虑子目录，本着“生命不息，折腾不止”的精神，我决定把博客迁移到Hexo。\n\nHexo也是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub，Hexo同样支持markdown，写起来也很顺手。因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文文档进行查看。\n准备工作我用的系统是ubuntu，所以下面命令均是在ubuntu上完成的。\n安装nodejs和npm\n123$ sudo apt-get install python-software-properties$ curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -$ sudo apt-get install nodejs\n安装nodejs和npm的方法网上还有很多，这里就不再赘述了。\n安装Hexo使用npm命令安装Hexo\n1$ npm install -g hexo-cli\n初始化博客\n123$ hexo init blog$ cd blog$ npm install\n以上命令完成后，会在目标目录生成以下的目录结构：\n12345678.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\n_config.yml 是博客的配置文件。\nscaffolds 是博客文章模板。\nsource 是博客文章目录。\nthemes 存放主题风格文件。\n\n配置HexoHexo的配置信息都储存在_config.yml中，需要注意的一点：冒号后面一定要加空格！\n下面是Hexo的一些基础配置：\n1234567891011121314# 网站信息title: #标题subtitle: #副标题description: #网站描述author: #作者昵称language: #网站语言，默认英语，设置简体汉语# 网址设置#网址 因为我的博客是放在子目录中，所以将url设置成'http://zhoushuo.me/blog'url: http://zhoushuo.me/blog/root: /blog/ #博客根目录，同上。# 主题配置theme: # 对应themes下存放主题的文件夹名\n如果是要部署到Github需要修改一下部署配置：\n12345# 部署配置deploy:  type: git  repo: # github仓库名  branch: master\n更多详细配置可以查看官方文档：https://hexo.io/zh-cn/docs/configuration.html\n解析我的博客是部署在我的云主机上的，所以需要在nginx配置里面添加一条解析：\n123location /blog/ &#123;    alias /home/ubuntu/www/blog/public/;&#125;\n这样在浏览器里输入网址就可以访问了。\n安装主题Hexo提供了很多主题，可以打开Hexo官方主题浏览查看，选择自己喜欢的主题。我这里使用的是icalm，下面也是以icalm为例：\n1$ git clone git@github.com:nameoverflow/hexo-theme-icalm.git\n启用主题：\n修改博客目录blog\\_config.yml中的theme属性，将其设置为icalm。\n1theme: icalm\n配置主题主题的配置在\\themes\\icalm\\_config.yml文件里面。每个主题的配置内容也都不太一样，一般来说，主题的作者都会有对主题的相关介绍，看他介绍的修改就可以了。我主要针对导航栏简单说明一下。\n123456#因为我的博客是放在子目录中，所以路径前面加了/blogmenu: #导航栏  Home: /blog/ #主页  Archive: /blog/archives/ #归档  Tags: /blog/tags/ #标签  About: /blog/about/ #关于\nHexo命令1234567891011121314npm install hexo -g     #安装Hexonpm update hexo -g    #升级 hexo init    #初始化博客#命令简写hexo n  \"我的博客\" == hexo new  \"我的博客\"   #新建文章hexo g == hexo generate   #生成hexo s == hexo server   #启动服务预览hexo d == hexo deploy   #部署hexo server     #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s    #静态模式hexo server -p 5000     #更改端口hexo server -i 192.168.1.1     #自定义 IPhexo clean     #清除缓存，若是网页正常情况下可以忽略这条命令\n注意，这里的命令都是作用在Hexo博客所在的文件夹中。\n写作博客基本配置完成了，主题也更换了，开始写一篇文章吧！\n1$ hexo n \"开博大吉\"\n这时候，你会看到一个 md 文件的路径：\n12$ hexo n \"开博大吉\"INFO  Created: ~/www/blog/source/_posts/开博大吉.md\n复制路径，用vim打开md文件\n1$ vim ~/www/blog/source/_posts/开博大吉.md\n然后就可以写博客内容了，写完之后保存退出。然后生成html文件，部署。\n1$ hexi g -d\n添加文章抬头信息Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。\n123456title:  #文章标题date:  #时间，一般不用改categories:  #目录分类tags:  #标签，格式可以是[Hexo,总结]，中间用英文逗号分开keywords:  #文章关键词，多个关键词用英文逗号隔开---\n迁移接下来就是把之前Firekylin里面的博文迁移到Hexo上。Hexo的md文件都保存在/blog/source/_posts/下，所以我只需要将Firekylin里导出的md文件上传到这个目录下，然后生成部署就可以了。\n到这里博客迁移就基本完成了，当然还有很多细节需要完善，就先写到这里，有时间继续折腾。\n","plink":"https://blog.zhoushuo.me/post/firekylin-hexo/"},{"title":"【笔记】 vim命令大全","date":"2018-03-20T03:39:21.000Z","updated":"2019-02-15T03:25:47.456Z","content":"光标控制命令“h”、”j”、”k”、”l”分别控制光标左、下、上、右移一格。\n“w”： 光标跳到下个字的开头。\n“e”： 光标跳到下个字的字尾。\n“b”： 光标回到上个字的开头。\n“)” ： 光标移至句尾\n“(“ ： 光标移至句首\n“}”： 光标移至段落开头\n“{“： 光标移至段落结尾\n“nl”： 光标移动该行的第n个位置，例如： “5l”表示移动到该行的第5个字符。\n“ctrl+b”： 屏幕往后移动一页。\n“ctrl+f”： 屏幕往前移动一页。\n“ctrl+u”： 屏幕往后移动半页。\n“ctrl+d”： 屏幕往前移动半页。\n—数字”0”： 移动到文本的开头。\n“G”： 移动到文件的最后。\n—“$”： 移动到光标所在行的行尾。\n“^”： 移动到光标所在行的行首。\n文本插入文本“i” ： 在光标前\n“I” ： 在当前行首\n“a”： 光标后\n“A”： 在当前行尾\n“o”： 在当前行之下新开一行\n“O”： 在当前行之上新开一行\n“r”： 替换当前字符\n“R”： 替换当前字符及其后的字符，直至按ESC键\n“s”： 从当前光标位置处开始，以输入的文本替代指定数目的字符\n“S”： 删除指定数目的行，并以所输入文本代替之\n“ncw”或”nCW”： 修改指定数目的字\n“nCC”： 修改指定数目的行\n删除命令“dd”： 删除整行\n“dw”： 删至下一个字的开头\n“ndw”或”ndW”： 删除光标处开始及其后的n-1个字\n“do”： 删至行首\n“d$”： 删至行尾\n“ndd”： 删除当前行及其后n-1行\n“x”或”X”： 删除一个字符，x删除光标后的，而X删除光标前的\n“Ctrl+u”： 删除输入方式下所输入的文本\n复制命令“yw”： 将光标所在之处到字尾的字符复制到缓冲区中。\n“nyw”： 复制n个字到缓冲区。\n“yy”： 复制光标所在行到缓冲区。\n“nyy”： 例如： “6yy”表示复制从光标所在行开始6行字符。\n“p”： 将缓冲区内的字符写到光标所在位置。\n查找与替换“/text”： 在文件中向前查找 text\n“?text”： 在文件中向后查找 text\n“n”： 在同一方向重复查找\n“N”： 在相反方向重复查找\n“ftext”：  在当前行向前查找 text\n“Ftext”： 在当前行向后查找 text\n“ttext”： 在当前行向前查找 text，并将光标定位在 text 的第一个字符\n“Ttext”：  在当前行向后查找 text，并将光标定位在 text 的第一个字符\n“:set ic”： 查找时忽略大小写\n“:set noic”： 查找时对大小写敏感\n“:ranges/pat1/pat2/g”： 用 newtext 替换 oldtext\n“:m,ns/oldtext/newtext”：  在 m 行通过 n，用 newtext 替换 oldtext\n“:g/text1/s/text2/text3”：  查找包含 text1 的行，用 text3 替换 text2\n撤消与重复“u”： 撤消最后一次修改\n“U”： 撤消当前行的所有修改\n“.”： 重复最后一次修改\n“,”： 以相反的方向重复前面的 f、F、t 或 T 查找命令\n“;”： 重复前面的 f、F、t 或 T 查找命令\n“n”： 重复前面的 / 或 ? 查找命令\n“N”： 以相反方向重复前面的 / 或 ? 命令\n末行模式操作“:set nu”： 列出行号\n“:set nonu”： 取消列出行号\n“:set ic”： 搜索时忽略大小写\n“:set noic”： 取消在搜索时忽略大小写\n“:n”： 跳到文件中的某一行,“n”表示一个数字，如输入数字15,再回车就会跳到文本的第15行\n“:!cmd”： 运行shell命令cmd\n文本缩进“ctrl+i”或”tab” 插入文本时，插入移动的宽度，移动宽度是事先定义好的\n“:set ai”： 打开自动缩进\n“:set sw=n”： 将移动宽度设置为 n 个字符\n“n&gt;”： 使 n 行都向右移动一个宽度，例如 3&gt;&gt; 就将接下来的三行每行都向右移动一个移动宽度\n保存和退出“:w”： 保存文件但不退出 vi\n“:w file”： 将修改保存在 file 中但不退出 vi\n“:wq” 或 “ZZ” 或 “:x”： 保存文件并退出 vi\n“:q!”： 不保存文件，退出 vi\n“:e!”： 放弃所有修改，从上次保存文件开始再编辑\n","thumbnail":"https://cdn.zhoushuo.me/vim.jpg","plink":"https://blog.zhoushuo.me/post/vim-command/"},{"title":"使用JS和Canvas做一个画板","date":"2018-03-10T17:22:14.000Z","updated":"2019-02-15T03:53:45.360Z","content":"前些天学习了HTML5的&lt;canvas&gt;元素，今天就来实践一下，用canvas做一个画板。\n\n首先说一下要实现的功能：\n\n切换画笔颜色\n调整笔刷粗细\n清空画布\n橡皮擦擦除\n撤销操作\n保存成图片\n兼容移动端（支持触摸）\n\n废话少说，先看最终效果：点击预览\n以下是实现过程。\n准备工作首先，准备个容器,也就是画板了。\n1&lt;canvas id=\"drawing-board\"&gt;&lt;/canvas&gt;\n然后初始化js：\n12let canvas = document.getElementById(\"drawing-board\");let ctx = canvas.getContext(\"2d\");\n我想把画板做成全屏的，所以接下来设置一下canvas的宽高。\n12345let pageWidth = document.documentElement.clientWidth;let pageHeight = document.documentElement.clientHeight;canvas.width = pageWidth;canvas.height = pageHeight;\n由于部分IE不支持canvas，如果要兼容IE，我们可以创建一个canvas，然后使用excanvas初始化，针对IE加上exCanvas.js，这里我们暂时先不考虑IE。\n实现一个简单的画板实现思路：监听鼠标事件，用drawCircle()方法把记录的数据画出来。\n\n设置初始化当前画布功能为画笔状态，painting = false，\n当鼠标按下时（mousedown），把painting设为true，表示正在画，鼠标没松开。把鼠标点记录下来。\n当按下鼠标的时候，鼠标移动（mousemove）就把点记录下来并画出来。\n如果鼠标移动过快，浏览器跟不上绘画速度，点与点之间会产品间隙，所以我们需要将画出的点用线连起来（lineTo()）。\n鼠标松开的时候（mouseup），把painting设为false。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546let painting = false;let lastPoint = &#123;x: undefined, y: undefined&#125;;//鼠标按下事件canvas.onmousedown = function (e) &#123;    painting = true;    let x = e.clientX;    let y = e.clientY;    lastPoint = &#123;\"x\": x, \"y\": y&#125;;    drawCircle(x, y, 5);&#125;;//鼠标移动事件canvas.onmousemove = function (e) &#123;    if (painting) &#123;        let x = e.clientX;        let y = e.clientY;        let newPoint = &#123;\"x\": x, \"y\": y&#125;;        drawLine(lastPoint.x, lastPoint.y, newPoint.x, newPoint.y,clear);        lastPoint = newPoint;    &#125;&#125;;//鼠标松开事件canvas.onmouseup = function () &#123;    painting = false;&#125;// 画点函数function drawCircle(x, y, radius) &#123;    ctx.save();    ctx.beginPath();    ctx.arc(x, y, radius, 0, Math.PI * 2);    ctx.fill();&#125;// 划线函数function drawLine(x1, y1, x2, y2) &#123;    ctx.lineWidth = 3;    ctx.lineCap = \"round\";    ctx.lineJoin = \"round\";    ctx.moveTo(x1, y1);    ctx.lineTo(x2, y2);    ctx.stroke();    ctx.closePath();&#125;\n橡皮擦功能实现思路\n\n获取橡皮擦元素\n设置橡皮擦初始状态，clear = false。\n监听橡皮擦click事件，点击橡皮擦，改变橡皮擦状态，clear = true。\nclear为true时，移动鼠标使用canvas剪裁（clip()）擦除画布。\n\n12345678910111213141516171819let eraser = document.getElementById(\"eraser\");let clear = false;eraser.onclick = function () &#123;    clear = true;&#125;;...javaScript...if (clear) &#123;    ctx.save();    ctx.globalCompositeOperation = \"destination-out\";    ctx.stroke();    ctx.closePath();    ctx.clip();    ctx.clearRect(0,0,canvas.width,canvas.height);    ctx.restore();&#125;...\n注意，在canvas中的裁剪和平时的裁剪功能不一样在这里，裁剪是指在裁剪区域去显示我们所画的图。\n兼容移动端实现思路：\n\n判断设备是否支持触摸\ntrue，则使用touch事件；false，则使用mouse事件\n\n1234567891011121314151617...if (document.body.ontouchstart !== undefined) &#123;    // 使用touch事件    anvas.ontouchstart = function (e) &#123;        // 开始触摸    &#125;    canvas.ontouchmove = function (e) &#123;        // 开始滑动    &#125;    canvas.ontouchend = function () &#123;        // 滑动结束    &#125;&#125;else&#123;    // 使用mouse事件    ...&#125;...\n这里需要注意的一点是，在touch事件里，是通过.touches[0].clientX和.touches[0].clientY来获取坐标的，这点要和mouse事件区别开。\n切换画笔颜色实现思路：\n\n获取颜色元素节点。\n点击颜色返回其颜色值，并赋给画布的ctx.strokeStyle。\n\n123456789let aColorBtn = document.getElementsByClassName(\"color-item\");for (let i = 0; i &lt; aColorBtn.length; i++) &#123;    aColorBtn[i].onclick = function () &#123;    for (let i = 0; i &lt; aColorBtn.length; i++) &#123;        activeColor = this.style.backgroundColor;        ctx.strokeStyle = activeColor;    &#125;&#125;\n清空画布实现思路：\n\n获取元素节点。\n点击清空按钮清空canvas画布。\n\n12345let reSetCanvas = document.getElementById(\"clear\");reSetCanvas.onclick = function () &#123;    ctx.clearRect(0, 0, canvas.width, canvas.height);&#125;;\n调整笔刷粗细实现思路：\n\n创建input[type=range]\n滑动range获取其value值，并赋给ctx.lineWidth\n\n12345let range = document.getElementById(\"range\");range.onchange = function()&#123;    lWidth = this.value;&#125;;\n保存成图片实现思路：\n\n获取canvas.toDateURL\n在页面里创建并插入一个a标签\na标签href等于canvas.toDateURL，并添加download属性\n点击保存按钮，a标签触发click事件\n\n1234567891011let save = document.getElementById(\"save\");save.onclick = function () &#123;    let imgUrl = canvas.toDataURL(\"image/png\");    let saveA = document.createElement(\"a\");    document.body.appendChild(saveA);    saveA.href = imgUrl;    saveA.download = \"zspic\" + (new Date).getTime();    saveA.target = \"_blank\";    saveA.click();&#125;;\n撤销实现思路：\n\n准备一个数组记录历史操作\n每次使用画笔前将当前绘图表面储存进数组\n点击撤销时，恢复到上一步的绘图表面\n\n12345678910111213141516171819canvas.ontouchstart = function (e) &#123;     // 在这里储存绘图表面    this.firstDot = ctx.getImageData(0, 0, canvas.width, canvas.height);    saveData(this.firstDot);    ...&#125;let undo = document.getElementById(\"undo\");let historyDeta = [];function saveData (data) &#123;    (historyDeta.length === 10) &amp;&amp; (historyDeta.shift()); // 上限为储存10步，太多了怕挂掉    historyDeta.push(data);&#125;undo.onclick = function()&#123;    if(historyDeta.length &lt; 1) return false;    ctx.putImageData(historyDeta[historyDeta.length - 1], 0, 0);    historyDeta.pop()&#125;;\n因为每次储存都是将一张图片存入内存，对性能影响较大，所以在这里设置了储存上限。\n总结这里用的知识点主要有：监听mouse、touch事件，以及canvas的moveTo()、lineTo()、stroke()、clip()、clearRect()等方法。我相信还有很多效果可以实现，比如说类似喷雾效果，铅笔字效果，艺术画效果，等等。日后有时间我会继续对这个画板进行优化，增加一些新的功能同时欢迎大家留言提问或者提出批评建议。\n最终代码：GitHub/zhoushuozh/drawingborad\n","thumbnail":"https://cdn.zhoushuo.me/zhoushuodrawing.png","plink":"https://blog.zhoushuo.me/post/drawing-borad/"},{"title":"HTML5 Canvas 基础","date":"2018-03-05T15:21:54.000Z","updated":"2019-02-15T03:22:24.755Z","content":"&lt;canvas&gt; 是HTML5新增的元素，可以用于绘制图形，制作照片，创建动画。&lt;canvas&gt; 标签只是图形容器，它没有自己的行为，必须使用脚本来绘制图形。\n\n创建一个canvas1&lt;canvas id=\"mycanvas\" width=\"300\" height=\"300\"&gt;&lt;/canvas&gt;\n&lt;canvas&gt;标签只有两个属性—— width和height，当没有设置宽度和高度的时候，&lt;canvas&gt; 的默认大小为300px×150px。需要注意的是，如果使用css来定义&lt;canvas&gt;的大小，在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。\n渲染上下文&lt;canvas&gt;元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成。\n&lt;canvas&gt;创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。\ncanvas起初是空白的，首先需要找到渲染上下文，然后在它的上面绘制。\n12var canvas=document.getElementById(\"mycanvas\");var ctx = canvas.getContext('2d');\n&lt;canvas&gt;有一个叫做 getContext()的方法，这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数，就是上下文的格式。\n检查浏览器兼容性最新版的 FireFox，Safari，Chrome 和 Opera 都支持 HTML5 canvas，但是 IE8及以下都不支持canvas。下面的代码用于检测浏览器的是否支持canvas。\n12345678var canvas = document.getElementById('mycanvas'); if (canvas.getContext)&#123;    var ctx = canvas.getContext('2d');    // drawing code here&#125; else &#123;    // canvas-unsupported code here&#125;\ncanvas 坐标在绘制图形之前，我们还应该先了解一下canvas中的坐标。canvas默认被网格所覆盖。通常来说网格中的一个单元相当于canvas元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点定位。\n绘制 canvas 图形好的，接下来我们就开始了解怎么使用Canvas的API绘制基本图形了 。\n1234567var canvas = document.getElementById('mycanvas'); if (canvas.getContext)&#123;    var ctx = canvas.getContext('2d');    ctx.fillStyle=\"red\";    ctx.fillRect(0,0,100,100);&#125;\n上面的两行代码绘制一个红色的矩形：\n设置fillStyle属性可以是css颜色，渐变，或图案。fillStyle默认设置是#000000（黑色）。\nfillRect(x,y,width,height)方法定义了矩形当前的填充方式，x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。\ncanvas 路径路径是通过线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。以下是所要用到的方法：\n\n\n\n函数\n描述\n\n\n\n\nstrokeStyle\n用于设置画笔绘制路径的颜色、渐变和模式 \n\n\nlineWidth\n定义绘制线条的宽度\n\n\nbeginPath()\n开始一个新的绘制路径 \n\n\nmoveTo(x,y)\n移动画笔到指定的坐标点(x,y)，该点就是新的子路径的起始点 \n\n\nlineTo(x,y)\n使用直线边接当前端点和指定的坐标点(x,y) \n\n\nstroke()\n沿着绘制路径的坐标点顺序绘制直线 \n\n\nclosePath()\n如果当前的绘制路径是打开的，则关闭掉该绘制路径\n\n\n\n这里需要注意的是，当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。\n下面的代码绘制了一个三角形：\n1234567891011function draw() &#123; var canvas = document.getElementById('canvas');     if (canvas.getContext)&#123;        var ctx = canvas.getContext('2d');        ctx.beginPath();        ctx.moveTo(75,50);        ctx.lineTo(100,75);        ctx.lineTo(100,25);        ctx.fill();    &#125;&#125;\ncanvas 圆弧绘制路径我们可以使用arc()方法。该方法有六个参数：x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准。参数anticlockwise为一个布尔值。为true时，是逆时针方向，否则顺时针方向。\n12345var canvas=document.getElementById(\"mycanvas\");var ctx=canvas.getContext(\"2d\");ctx.beginPath();ctx.arc(95,50,40,0,2*Math.PI);ctx.stroke();\n注意：arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees。\ncanvas 文本canvas 提供了两种方法来渲染文本：\nfillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。\nstrokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。\n文本被填充方式：\n1234var canvas=document.getElementById(\"mycanvas\");var ctx=canvas.getContext(\"2d\");ctx.font=\"30px Arial\";ctx.fillText(\"Hello World\",10,50);\n文本边框备绘制方式：\n1234var canvas=document.getElementById(\"mycanvas\");var ctx=canvas.getContext(\"2d\");ctx.font=\"30px Arial\";ctx.strkeText(\"Hello World\",10,50);\ncanvas 图像引入图像到canvas里需要以下两步基本操作：\n\n获取一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片。\n使用drawImage()函数将图片绘制到画布上。\n\n获取图片和绘制图片，下面只展示最简单的一种：\n1234var canvas=document.getElementById(\"mycanvas\");var ctx=canvas.getContext(\"2d\");var img=document.getElementById(\"img\");ctx.drawImage(img,10,10);\ndrawImage有三个参数：drawImage(image, x, y)。其中image是image或者 canvas对象，x和y是其在目标canvas里的起始坐标。\n小结今天已经很晚了，关于canvas暂时就先到这里，以上就是关于canvas的基础功能的一些总结。\n","plink":"https://blog.zhoushuo.me/post/html5-canvas/"},{"title":"堆排序解析及JavaScript实现","date":"2018-02-27T17:35:21.000Z","updated":"2019-02-15T03:58:59.716Z","content":"堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n什么是堆在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。\n二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2i - 1 个结点；深度为 k 的二叉树至多有 2k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。\n二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）\n满二叉树：一棵深度为 k，且有 2k - 1 个节点称之为满二叉树\n完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树。\n堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n通常堆是通过一维数组来实现的，在数组起始位置为0的情形中：\n\nParent(i) = floor((i-1)/2)，i 的父节点下标\nLeft(i) = 2i + 1，i 的左子节点下标\nRight(i) = 2(i + 1)，i 的右子节点下标\n\n堆排序步骤最大堆调整：\n\n初始化，i从最后一个父节点开始调整\n建立父节点下标和子节点下标\n先比较两个子节点大小，选择最大的\n如果父节点小宇子节点时，交换父子內容再继续子节点和孙节点比较\n先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕\n\n流程图\nJavaScript实现1234567891011121314151617181920212223242526272829303132function heapSort(arr) &#123;    // 交换函数    function swap(i, j) &#123;        var tmp = arr[i];        arr[i] = arr[j];        arr[j] = tmp;    &#125;    function max_heapify(start, end) &#123;        //建立父节点下标和子节点下标        var dad = start;        var son = dad * 2 + 1;        if (son &gt;= end)//若子节点下标超过范围直接跳出函数            return;        if (son + 1 &lt; end &amp;&amp; arr[son] &lt; arr[son + 1])//先比较两个子节点大小，选择最大的            son++;        if (arr[dad] &lt;= arr[son]) &#123;//如果父节点小于子节点时，交换父子內容再继续子节点和孙节点比较            swap(dad, son);            max_heapify(son, end);        &#125;    &#125;    var len = arr.length;    //初始化，i从最后一个父节点开始调整    for (var i = Math.floor(len / 2) - 1; i &gt;= 0; i--)&#123;        max_heapify(i, len);    &#125;    // 先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕    for (var i = len - 1; i &gt; 0; i--) &#123;        swap(0, i);        max_heapify(0, i);    &#125;    return arr;&#125;\n验证12heapSort([15, 23, 14, 26, 14, 85, 17, 12, 3, 18, 45, 96, 7, 74, 45, 15, 12, 26, 12, 53]);// 输出 [3, 7, 12, 12, 12, 14, 14, 15, 15, 17, 18, 23, 26, 26, 45, 45, 53, 74, 85, 96]\n参考内容\n二叉树 - 维基百科\n堆排序 - 维基百科\n堆排序 - bubkoo\n算法可视化\n\n","plink":"https://blog.zhoushuo.me/post/heap-sort/"},{"title":"计数排序解析及JavaScript实现","date":"2018-02-26T14:32:45.000Z","updated":"2019-02-15T03:17:22.886Z","content":"计数排序（Counting sort）是一种稳定的线性时间排序算法。\n计数排序使用一个额外的数组}C ，其中第i个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n+k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。\n\n由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\n计数算法步骤\n找出待排序的数组中最大和最小的元素\n统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项\n对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）\n反向填充目标数组：将每个元素 i 放在新数组的第 C [i] 项，每放一个元素就将 C[i] 减去1\n\n流程图\nJavaScript代码实现123456789101112131415161718192021222324252627function countSort(arr,min,max)&#123;  var len =arr.length,      // 桶数组       count = [],      // 输出数组        result = [];  // 找出输入数组中最大值和最小值  var max = Math.max.apply(&#123;&#125;,arr);      min = Math.min.apply(&#123;&#125;,arr);  // 初始化桶数组，从最小值开始，到最大值结束  for(var i = min; i &lt;= max; i++)&#123;    count[i] = 0;  &#125;  // 遍历输入数组，填充count  for(var j=0; j &lt; len; j++)&#123;    count[arr[j]]++;  &#125;  for(var k = 0; k &lt;= max; k++)&#123;    // 按顺序将值推入输出数组，并将对应下标减1    while(count[k]-- &gt; 0)&#123;      result.push(k);    &#125;  &#125;  return result;&#125;\n验证1234countSort([13, 44, 38, 26, 47, 15, 19, 26, 27, 15, 46, 14, 19, 50, 48]);// 输出[13, 14, 15, 15, 19, 19, 26, 26, 27, 38, 44, 46, 47, 48, 50]countSort([43,41,15,13,48,13,74,35,12,62,15,45]);// 输出 [12, 13, 13, 15, 15, 35, 41, 43, 45, 48, 62, 74]\n总结计数排序就是简单的桶排序，一个桶代表数组中一个数出现的个数，所以需要一个和数组数字范围一样大的辅助数组，一般用在范围小于100的排序，时间复杂度为O(n)，空间复杂度为数组的数字范围。\n参考内容\n计数排序 - 维基百科\n排序可视化 - VisuAlgo\n\n","plink":"https://blog.zhoushuo.me/post/count-sort/"},{"title":"JS函数节流(throttle)与函数去抖(debounce)","date":"2018-01-18T13:23:43.000Z","updated":"2019-02-15T03:23:31.135Z","content":"在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。如：改变窗口大小（resize）、鼠标滚动（scroll）、鼠标移动（mousemove），如果把逻辑函数直接绑定到这些事件上，会严重影响性能，再比如把ajax请求直接绑定到keydown事件上，将在用户输入时产生频率很高的ajax请求，给服务器造成不必要的响应压力。\n\n函数节流 (throttle)每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。即设定一个时间间隔，当时间间隔大于或等于时，立即执行一次方法。\n12345678910111213function throttle(fn, delta, context) &#123;    var safe = true;    return function() &#123;        var args = arguments;        if(safe) &#123;            fn.call(context, args)            safe = false            setTimeout(function() &#123;                safe = true            &#125;, delta)        &#125;    &#125;&#125;\n函数防抖 (debounce)固定的时间间隔内，如果事件再次被触发，则重置时间，直到大于等于时间间隔才执行方法。\n123456789101112function debounce(fn, delta, context) &#123;    var timeoutID = null;    return function() &#123;        if(timeoutID) &#123;        clearTimeout(timeoutID);    &#125;    var args = arguments;    timeoutID = setTimeout(function() &#123;            fn.apply(context, args);        &#125;, delta);    &#125;&#125;\n区别throttle：一辆定时的地铁，每五分钟出发一辆，不管你有没有上到车，只要命令下来过五分钟之后就出发。\ndebounce：就跟电梯的原理一样，只要10s之内有人来就重置时间，再过10s，直到大于等于10s之后没人进来才出发。\n小结函数节流(throttle)和函数防抖(debounce)都是通过延时逻辑操作来提升性能的方法，在前端优化中是常见且重要的解决方式。可以从概念和实际应用中理解两者的区别，在需要的时候选择合适的方法处理。\n","plink":"https://blog.zhoushuo.me/post/js-throttle-debounce/"},{"title":"CSS多行文本溢出省略显示","date":"2017-10-13T12:52:21.000Z","updated":"2019-02-15T03:25:12.373Z","content":"文本溢出我们经常用到的应该就是text-overflow:ellipsis了，相信大家也很熟悉，但是对于多行文本的溢出处理确接触的不是很多，最近在公司群里面有同事问到，并且自己也遇到过这个问题，所以专门研究过这个问题。\n\n首先我们回顾一下以前实现单行缩略是可以通过下面的代码实现的：\n123overflow: hidden;text-overflow: ellipsis;white-space: nowrap;\nWebKit内核浏览器解决办法首先，WebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性：\n\ndisplay: -webkit-box 将对象作为弹性伸缩盒子模型显示；\n-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式；\ntext-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。\n\n具体代码参考如下：\n12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical;\n这个方法合适WebKit浏览器或移动端（绝大部分是WebKit内核的）浏览器，效果可以查看：\n\n\n其他浏览器的解决方案目前没有什么CSS的属性可以直接控制多行文本的省略显示，比较靠谱的办法应该就是利用相对定位在最后面加上一个省略号了，代码可以参考下面：\n123456789101112131415p &#123;    position:relative;    line-height:1.5em;    /* 高度为需要显示的行数*行高，比如这里我们显示两行，则为3 */    height:3em;    overflow:hidden;&#125;p:after &#123;    content:\"...\";    position:absolute;    bottom:0;    right:0;    padding: 0 5px;    background-color: #fff;&#125;\n效果如下：\n\n\n不过这样会有一点问题：\n\n需要知道显示的行数并设置行高才行；\nIE6/7不支持after和content，需要添加一个标签来代替；\n省略号的背景颜色跟文本背景颜色一样，并且可能会遮住部分文字，建议可以使用渐变的png背景图片代替。\n\n","plink":"https://blog.zhoushuo.me/post/text-overflow/"},{"title":"friends","date":"2019-04-03T15:11:50.686Z","updated":"2019-01-15T09:14:07.991Z","content":"友链申请注意事项\n先友后链，先友后链, 先友后链：毕竟是“友链”不是“导航页面”\n贵站至少几十篇原创文章：分享精神值得认可\n申请前请先添加本站链接：我寻求友链的时候也是这样做的\n时间很长，慢慢了解：如果多次没有回复您的友链申请，还请在前面三点涉及的方面稍作改进\n\n申请方式\n推荐方式：直接在下方评论区留言\n发送Email:  zhoushuozh@gmail.com\n\n申请格式( 我的友链信息 )：12345请首先确定在 贵站 可以看到本站链接 ！！！链接：https://zhoushuo.me/昵称：zhoushuo头像连接：https://cn.gravatar.com/avatar/b20750c40cd911256ddbd76a7f7e724c介绍：目光露着温暖，心间藏着想念","plink":"https://blog.zhoushuo.me/friends/"},{"title":"About","date":"2018-03-17T16:00:00.000Z","updated":"2019-02-15T06:07:55.758Z","content":"关于我周硕，95后，坐标郑州。\n懂点设计，擅长前端。\n水平有限，还没到输出知识的程度，此博客主要用于记录和总结，文章如有错误之处欢迎批评指出。\n本站信息本站使用Hexo生成，主题inside，部署在Github，腾讯云域名解析，评论系统Gitalk。\n联系方式mail：zhoushuozh#gmail.com\ngithub：@zhoushuozh\nweibo：@石页周\n","plink":"https://blog.zhoushuo.me/about/"}]