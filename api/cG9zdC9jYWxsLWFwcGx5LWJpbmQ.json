{"title":"JS中的call、apply、bind","date":"2018-05-10T14:18:26.000Z","slug":"call-apply-bind","comments":true,"tags":["JavaScript"],"categories":["前端"],"updated":"2019-01-20T08:53:54.993Z","content":"<p>在JavaScript中，call、apply和bind 是Function对象自带的三个方法，这三个方法的共同点：</p>\n<ol>\n<li>都是用来改变函数的this对象的指向的。</li>\n<li>第一个参数都是this要指向的对象。</li>\n<li>都可以利用后续参数传参。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><p>语法 ：<code>fun.call(thisArg, arg1, arg2, ...)</code></p>\n<blockquote>\n<p><code>call()</code> 方法调用一个函数, 其具有一个指定的<code>this</code>值和分别地提供的参数(<strong>参数的列表</strong>) 。</p>\n</blockquote>\n<p>可以让call()中的对象调用当前对象所拥有的function。可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。 </p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>语法：<code>fun.apply(thisArg, [argsArray])</code></p>\n<blockquote>\n<p><code>apply()</code> 方法调用一个函数, 其具有一个指定的<code>this</code>值，以及作为一个数组（或<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects\" target=\"_blank\" rel=\"noopener\">类似数组的对象</a>）提供的参数。 </p>\n</blockquote>\n<p>在调用一个存在的函数时，你可以为其指定一个 <code>this</code> 对象。 <code>this</code> 指当前对象，也就是正在调用这个函数的对象。 使用 <code>apply</code>， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 </p>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><blockquote>\n<p><code>bind()</code>方法创建一个新的函数, 当被调用时，将其<code>this</code>关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 </p>\n</blockquote>\n<p>语法：<code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<p>bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的<code>call</code>。当<strong>新函数</strong>被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用<code>new</code>操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 </p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><h5 id=\"call和apply的区别\"><a href=\"#call和apply的区别\" class=\"headerlink\" title=\"call和apply的区别\"></a>call和apply的区别</h5><p>他们俩之间的差别在于参数的区别，call和aplly的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">hello.call(<span class=\"keyword\">this</span>,<span class=\"string\">\"tsrot\"</span>,<span class=\"number\">24</span>);</span><br><span class=\"line\">hello.apply(<span class=\"keyword\">this</span>,[<span class=\"string\">\"tsrot\"</span>,<span class=\"number\">24</span>]);</span><br></pre></td></tr></table></figure>\n<h5 id=\"call-apply与bind的差别\"><a href=\"#call-apply与bind的差别\" class=\"headerlink\" title=\"call, apply与bind的差别\"></a>call, apply与bind的差别</h5><p>call 和 apply 改变了函数的 this 上下文后便执行该函数, 而 bind 则是返回改变了上下文的一个函数  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    x: <span class=\"number\">81</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    getX: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.getX.bind(obj)());  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.getX.call(obj));    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.getX.apply(obj));</span><br></pre></td></tr></table></figure>\n<h2 id=\"运用场景\"><a href=\"#运用场景\" class=\"headerlink\" title=\"运用场景\"></a>运用场景</h2><h3 id=\"实现继承\"><a href=\"#实现继承\" class=\"headerlink\" title=\"实现继承\"></a>实现继承</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.showName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    Animal.call(<span class=\"keyword\">this</span>, name); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat(<span class=\"string\">'Black Cat'</span>);</span><br><span class=\"line\">cat.showName();</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组追加\"><a href=\"#数组追加\" class=\"headerlink\" title=\"数组追加\"></a>数组追加</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">[].push.apply(arr1, arr2)</span><br><span class=\"line\"><span class=\"comment\">// 使用一个辅助的空数组（为了访问非静态方法)，就是把arr2利用apply的数组参数特性push到arr1中.</span></span><br><span class=\"line\"><span class=\"comment\">// 这样通过解构可以写成 arr1.push(...arr2), 如果需要返回一个全新的对象，还可以使用 [...arr1, ...arr2]。</span></span><br><span class=\"line\"><span class=\"comment\">// 还可以写成var newArr =  arr1.concat(arr2)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arr1 [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"comment\">// arr2 [4,5,6]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"将伪数组转化为数组\"><a href=\"#将伪数组转化为数组\" class=\"headerlink\" title=\"将伪数组转化为数组\"></a>将伪数组转化为数组</h3><p>js中的伪数组具有length属性，并且可以通过0、1、2…下标来访问其中的元素，但是没有Array中的push、pop等方法。我们可以利用call、apply来将其转化为真正的数组这样便可以方便地使用数组方法了。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'shifeng'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'xingyun'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'ruxue'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(arrayLike)</span><br><span class=\"line\"><span class=\"comment\">// 上面arr便是一个包含arrayLike元素的真正的数组啦.</span></span><br><span class=\"line\"><span class=\"comment\">// 注意数据结构必须是以数字为下标而且一定要有length属性!</span></span><br></pre></td></tr></table></figure>","prev":{"title":"理解JS中的闭包","slug":"js-closure"},"next":{"title":"移动端Web页面适配方案","slug":"mobile-web-adaptation"},"link":"https://blog.zhoushuo.me/post/call-apply-bind/","toc":[{"title":"定义","id":"定义","index":"1","children":[{"title":"call","id":"call","index":"1.1"},{"title":"apply","id":"apply","index":"1.2"},{"title":"bind","id":"bind","index":"1.3"}]},{"title":"区别","id":"区别","index":"2"},{"title":"运用场景","id":"运用场景","index":"3","children":[{"title":"实现继承","id":"实现继承","index":"3.1"},{"title":"数组追加","id":"数组追加","index":"3.2"},{"title":"将伪数组转化为数组","id":"将伪数组转化为数组","index":"3.3"}]}],"copyright":{"author":"zhoushuo","link":"<a href=\"https://blog.zhoushuo.me/post/call-apply-bind/\" title=\"JS中的call、apply、bind\">https://blog.zhoushuo.me/post/call-apply-bind/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2018年5月10日"}}