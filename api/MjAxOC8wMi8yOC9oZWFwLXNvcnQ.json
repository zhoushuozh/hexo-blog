{"title":"堆排序解析及JavaScript实现","date":"2018-02-27T17:35:21.000Z","link":"2018/02/28/heap-sort","comments":true,"tags":["JavaScript","算法"],"categories":["未分类"],"updated":"2019-02-15T03:58:59.716Z","content":"<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是堆\">什么是堆<a href=\"2018/02/28/heap-sort#什么是堆\"></a></h2><p>在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于<code>2</code>的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。</p>\n<p>二叉树的每个结点至多只有二棵子树（不存在度大于 <code>2</code> 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 <code>i</code> 层至多有 <code>2i - 1</code> 个结点；深度为 <code>k</code> 的二叉树至多有 <code>2k - 1</code> 个结点；对任何一棵二叉树 <code>T</code>，如果其终端结点数为 <code>n0</code>，度为 <code>2</code> 的结点数为 <code>n2</code>，则<code>n0 = n2 + 1</code>。</p>\n<p>二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree）</p>\n<p>满二叉树：一棵深度为 <code>k</code>，且有 <code>2k - 1</code> 个节点称之为满二叉树</p>\n<p>完全二叉树：深度为 <code>k</code>，有 <code>n</code> 个节点的二叉树，当且仅当其每一个节点都与深度为 <code>k</code> 的满二叉树中序号为 <code>1</code> 至 <code>n</code> 的节点对应时，称之为完全二叉树。</p>\n<h2 id=\"堆排序\">堆排序<a href=\"2018/02/28/heap-sort#堆排序\"></a></h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<p>通常堆是通过一维数组来实现的，在数组起始位置为0的情形中：</p>\n<ul>\n<li><code>Parent(i) = floor((i-1)/2)</code>，<code>i</code> 的父节点下标</li>\n<li><code>Left(i) = 2i + 1</code>，<code>i</code> 的左子节点下标</li>\n<li><code>Right(i) = 2(i + 1)</code>，<code>i</code> 的右子节点下标</li>\n</ul>\n<h2 id=\"堆排序步骤\">堆排序步骤<a href=\"2018/02/28/heap-sort#堆排序步骤\"></a></h2><p>最大堆调整：</p>\n<ol>\n<li>初始化，i从最后一个父节点开始调整</li>\n<li>建立父节点下标和子节点下标</li>\n<li>先比较两个子节点大小，选择最大的</li>\n<li>如果父节点小宇子节点时，交换父子內容再继续子节点和孙节点比较</li>\n<li>先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕</li>\n</ol>\n<h3 id=\"流程图\">流程图<a href=\"2018/02/28/heap-sort#流程图\"></a></h3><p><img src=\"https://cdn.zhoushuo.me/heapsort.jpg\" alt=\"堆排序流程图\" class=\"article-img\"></p>\n<h2 id=\"JavaScript实现\">JavaScript实现<a href=\"2018/02/28/heap-sort#JavaScript实现\"></a></h2><figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">heapSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 交换函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">swap</span>(<span class=\"params\">i, j</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> tmp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[j];</span><br><span class=\"line\">        arr[j] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">max_heapify</span>(<span class=\"params\">start, end</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//建立父节点下标和子节点下标</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dad = start;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> son = dad * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (son &gt;= end)<span class=\"comment\">//若子节点下标超过范围直接跳出函数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (son + <span class=\"number\">1</span> &lt; end &amp;&amp; arr[son] &lt; arr[son + <span class=\"number\">1</span>])<span class=\"comment\">//先比较两个子节点大小，选择最大的</span></span><br><span class=\"line\">            son++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[dad] &lt;= arr[son]) &#123;<span class=\"comment\">//如果父节点小于子节点时，交换父子內容再继续子节点和孙节点比较</span></span><br><span class=\"line\">            swap(dad, son);</span><br><span class=\"line\">            max_heapify(son, end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"comment\">//初始化，i从最后一个父节点开始调整</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">        max_heapify(i, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        swap(<span class=\"number\">0</span>, i);</span><br><span class=\"line\">        max_heapify(<span class=\"number\">0</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"验证\">验证<a href=\"2018/02/28/heap-sort#验证\"></a></h3><figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heapSort([<span class=\"number\">15</span>, <span class=\"number\">23</span>, <span class=\"number\">14</span>, <span class=\"number\">26</span>, <span class=\"number\">14</span>, <span class=\"number\">85</span>, <span class=\"number\">17</span>, <span class=\"number\">12</span>, <span class=\"number\">3</span>, <span class=\"number\">18</span>, <span class=\"number\">45</span>, <span class=\"number\">96</span>, <span class=\"number\">7</span>, <span class=\"number\">74</span>, <span class=\"number\">45</span>, <span class=\"number\">15</span>, <span class=\"number\">12</span>, <span class=\"number\">26</span>, <span class=\"number\">12</span>, <span class=\"number\">53</span>]);</span><br><span class=\"line\"><span class=\"comment\">// 输出 [3, 7, 12, 12, 12, 14, 14, 15, 15, 17, 18, 23, 26, 26, 45, 45, 53, 74, 85, 96]</span></span><br></pre></td></tr></table></div></figure>\n<h2 id=\"参考内容\">参考内容<a href=\"2018/02/28/heap-sort#参考内容\"></a></h2><ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91\" target=\"_blank\" rel=\"noopener\">二叉树 - 维基百科</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"noopener\">堆排序 - 维基百科</a></li>\n<li><a href=\"http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/\" target=\"_blank\" rel=\"noopener\">堆排序 - bubkoo</a></li>\n<li><a href=\"https://www.cs.usfca.edu/~galles/visualization/HeapSort.html\" target=\"_blank\" rel=\"noopener\">算法可视化</a></li>\n</ul>\n","prev":{"title":"HTML5 Canvas 基础","link":"2018/03/05/html5-canvas"},"next":{"title":"计数排序解析及JavaScript实现","link":"2018/02/26/count-sort"},"plink":"https://blog.zhoushuo.me/2018/02/28/heap-sort/","toc":[{"title":"什么是堆","id":"什么是堆","index":"1"},{"title":"堆排序","id":"堆排序","index":"2"},{"title":"堆排序步骤","id":"堆排序步骤","index":"3","children":[{"title":"流程图","id":"流程图","index":"3.1"}]},{"title":"JavaScript实现","id":"JavaScript实现","index":"4","children":[{"title":"验证","id":"验证","index":"4.1"}]},{"title":"参考内容","id":"参考内容","index":"5"}],"copyright":{"author":"zhoushuo","link":"<a href=\"https://blog.zhoushuo.me/2018/02/28/heap-sort/\" title=\"堆排序解析及JavaScript实现\">https://blog.zhoushuo.me/2018/02/28/heap-sort/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}